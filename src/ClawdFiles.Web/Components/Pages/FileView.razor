@page "/{BucketId}/{*FilePath}"
@using ClawdFiles.Application.Interfaces
@using Markdig
@inject IFileHeaderRepository FileRepo
@inject IFileStorage FileStorage
@rendermode InteractiveServer

<PageTitle>@FilePath</PageTitle>

<div style="padding-top: 40px;">
    @if (fileHeader is null)
    {
        <div class="terminal-panel" style="padding: 40px; text-align: center;">
            <p style="color: var(--abyss-muted); font-family: var(--font-mono); font-size: 0.85rem;">
                File not found.
            </p>
        </div>
    }
    else
    {
        <div class="breadcrumb-path">
            <a href="/">home</a>
            <span class="breadcrumb-path-sep">/</span>
            <a href="/@BucketId">@BucketId</a>
            <span class="breadcrumb-path-sep">/</span>
            <span>@fileHeader.Path</span>
        </div>

        <h1 class="hero-title" style="font-size: 1.6rem !important; margin-bottom: 16px;">@fileHeader.Path</h1>

        <div class="meta-bar" style="margin-bottom: 28px;">
            <span class="file-badge">@GetShortType(fileHeader.ContentType)</span>
            <span class="meta-tag">
                <span class="meta-tag-label">Size</span> @FormatSize(fileHeader.SizeBytes)
            </span>
            <span class="meta-tag">
                <span class="meta-tag-label">Uploaded</span> @fileHeader.UploadedAt.ToString("u")
            </span>
            <span class="meta-tag meta-tag--cyan">
                <span class="meta-tag-label">Short</span>
                <a href="/s/@fileHeader.ShortCode" style="color: var(--abyss-cyan); text-decoration: none;">/s/@fileHeader.ShortCode</a>
            </span>
        </div>

        @* === Preview section === *@
        <div style="margin-bottom: 28px;">
            @switch (previewKind)
            {
                case PreviewKind.Image:
                    <div class="image-preview">
                        <img src="/raw/@BucketId/@FilePath" alt="@fileHeader.Path" />
                    </div>
                    break;

                case PreviewKind.Video:
                    <div class="video-preview">
                        <video controls preload="metadata" style="max-width: 100%; max-height: 600px; display: block;">
                            <source src="/raw/@BucketId/@FilePath" type="@fileHeader.ContentType" />
                        </video>
                    </div>
                    break;

                case PreviewKind.Audio:
                    <div style="padding: 8px 0;">
                        <audio controls style="width: 100%; max-width: 500px;">
                            <source src="/raw/@BucketId/@FilePath" type="@fileHeader.ContentType" />
                        </audio>
                    </div>
                    break;

                case PreviewKind.Markdown:
                    <div class="markdown-preview">
                        @((MarkupString)renderedHtml)
                    </div>
                    break;

                case PreviewKind.Csv:
                    <div class="csv-preview-wrapper">
                        <table class="csv-preview">
                            @if (csvRows.Count > 0)
                            {
                                <thead>
                                    <tr>
                                        @foreach (var cell in csvRows[0])
                                        {
                                            <th>@cell</th>
                                        }
                                    </tr>
                                </thead>
                                <tbody>
                                    @foreach (var row in csvRows.Skip(1))
                                    {
                                        <tr>
                                            @foreach (var cell in row)
                                            {
                                                <td>@cell</td>
                                            }
                                        </tr>
                                    }
                                </tbody>
                            }
                        </table>
                    </div>
                    break;

                case PreviewKind.Code:
                    <CodePreview Content="@codeContent" FilePath="@FilePath" />
                    break;

                case PreviewKind.TooLarge:
                    <div class="preview-notice">
                        File too large for preview (max 1 MB for text-based previews).
                    </div>
                    break;
            }
        </div>

        <div style="display: flex; gap: 10px;">
            <MudButton Href="@($"/raw/{BucketId}/{FilePath}")"
                       Variant="Variant.Filled"
                       Color="Color.Primary">
                Download File
            </MudButton>
            <MudButton Href="@($"/{BucketId}")"
                       Variant="Variant.Outlined"
                       Color="Color.Default">
                Back to bucket
            </MudButton>
        </div>
    }
</div>

@code {
    [Parameter] public string BucketId { get; set; } = "";
    [Parameter] public string FilePath { get; set; } = "";
    private ClawdFiles.Domain.Entities.BucketFileHeader? fileHeader;

    private PreviewKind previewKind = PreviewKind.None;
    private string renderedHtml = "";
    private string codeContent = "";
    private List<string[]> csvRows = new();

    private const long MaxPreviewBytes = 1024 * 1024; // 1 MB
    private const int MaxCsvRows = 500;

    private enum PreviewKind { None, Image, Video, Audio, Markdown, Csv, Code, TooLarge }

    protected override async Task OnInitializedAsync()
    {
        fileHeader = await FileRepo.FindByBucketAndPathAsync(BucketId, FilePath);
        if (fileHeader is null) return;

        previewKind = Classify(fileHeader.ContentType, fileHeader.Path);

        if (previewKind is PreviewKind.Markdown or PreviewKind.Csv or PreviewKind.Code)
        {
            if (fileHeader.SizeBytes > MaxPreviewBytes)
            {
                previewKind = PreviewKind.TooLarge;
                return;
            }

            var content = await LoadTextContentAsync();
            if (content is null) { previewKind = PreviewKind.None; return; }

            switch (previewKind)
            {
                case PreviewKind.Markdown:
                    renderedHtml = RenderMarkdown(content);
                    break;
                case PreviewKind.Csv:
                    csvRows = ParseCsv(content);
                    break;
                case PreviewKind.Code:
                    codeContent = content;
                    break;
            }
        }
    }

    private static PreviewKind Classify(string contentType, string path)
    {
        if (contentType.StartsWith("image/")) return PreviewKind.Image;
        if (contentType.StartsWith("video/")) return PreviewKind.Video;
        if (contentType.StartsWith("audio/")) return PreviewKind.Audio;

        var ext = System.IO.Path.GetExtension(path)?.ToLowerInvariant() ?? "";

        if (ext == ".md" || contentType == "text/markdown") return PreviewKind.Markdown;
        if (ext == ".csv" || contentType == "text/csv") return PreviewKind.Csv;

        if (!string.IsNullOrEmpty(ext) && CodePreview.HasGrammar(ext))
            return PreviewKind.Code;

        return PreviewKind.None;
    }

    private static string RenderMarkdown(string markdown)
    {
        var pipeline = new MarkdownPipelineBuilder()
            .DisableHtml()
            .UseAdvancedExtensions()
            .Build();

        var html = Markdown.ToHtml(markdown, pipeline);
        html = HighlightMarkdownCodeBlocks(html);
        return html;
    }

    private static string HighlightMarkdownCodeBlocks(string html)
    {
        var pattern = new System.Text.RegularExpressions.Regex(
            @"<pre><code\s+class=""language-(\w+)"">([^<]*(?:<(?!/code>)[^<]*)*)</code></pre>",
            System.Text.RegularExpressions.RegexOptions.Singleline);

        return pattern.Replace(html, match =>
        {
            var langHint = match.Groups[1].Value;
            var code = System.Net.WebUtility.HtmlDecode(match.Groups[2].Value);

            var scope = CodePreview.ResolveScopeFromHint(langHint);
            if (string.IsNullOrEmpty(scope)) return match.Value;

            var highlighted = CodePreview.HighlightWithScope(code, scope);
            return $"<pre><code>{highlighted}</code></pre>";
        });
    }

    private async Task<string?> LoadTextContentAsync()
    {
        await using var stream = await FileStorage.GetFileStreamAsync(BucketId, FilePath);
        if (stream is null) return null;
        using var reader = new StreamReader(stream);
        var buffer = new char[MaxPreviewBytes];
        var read = await reader.ReadBlockAsync(buffer, 0, buffer.Length);
        return new string(buffer, 0, read);
    }

    private static List<string[]> ParseCsv(string content)
    {
        var rows = new List<string[]>();
        using var reader = new StringReader(content);
        string? line;
        while ((line = reader.ReadLine()) is not null && rows.Count < MaxCsvRows)
        {
            rows.Add(ParseCsvLine(line));
        }
        return rows;
    }

    private static string[] ParseCsvLine(string line)
    {
        var fields = new List<string>();
        var i = 0;
        while (i <= line.Length)
        {
            if (i == line.Length) { fields.Add(""); break; }

            if (line[i] == '"')
            {
                var sb = new System.Text.StringBuilder();
                i++;
                while (i < line.Length)
                {
                    if (line[i] == '"')
                    {
                        if (i + 1 < line.Length && line[i + 1] == '"')
                        {
                            sb.Append('"');
                            i += 2;
                        }
                        else
                        {
                            i++;
                            break;
                        }
                    }
                    else
                    {
                        sb.Append(line[i]);
                        i++;
                    }
                }
                fields.Add(sb.ToString());
                if (i < line.Length && line[i] == ',') i++;
            }
            else
            {
                var next = line.IndexOf(',', i);
                if (next == -1)
                {
                    fields.Add(line[i..]);
                    break;
                }
                fields.Add(line[i..next]);
                i = next + 1;
            }
        }
        return fields.ToArray();
    }

    private static string FormatSize(long bytes)
    {
        const long kb = 1024;
        const long mb = 1024 * 1024;
        const long gb = 1024 * 1024 * 1024;
        if (bytes >= gb) return $"{bytes / (double)gb:F1} GB";
        if (bytes >= mb) return $"{bytes / (double)mb:F1} MB";
        if (bytes >= kb) return $"{bytes / (double)kb:F1} KB";
        return $"{bytes} B";
    }

    private static string GetShortType(string contentType)
    {
        var sub = contentType.Contains('/') ? contentType.Split('/')[1] : contentType;
        return sub.Length > 10 ? sub[..10] : sub;
    }
}
